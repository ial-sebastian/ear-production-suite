#Plugins
The plugins are defined within the [ear-production-suite](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite) subfolder.

Within this, a library of shared code is defined within the [lib](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/lib) directory.

Individual plugins are defined within the [plugins](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/plugins) directory.

This distinction is partly to enable code reuse between plugins, but also serves to isolate the front-end, JUCE dependent code from the code handling the metadata model and inter plugin communication. This also makes testing easier as
unit testing with JUCE defined plugins can be a little tricky.

Some cmake [magic](https://github.com/ebu/ear-production-suite/blob/main/cmake_modules/juce_helpers.cmake) is used for adding JUCE as a dependency to each plugin

There are three categories of plugin.
##Source plugins
###[Object](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/plugins/object)
For authoring metadata that applies to individual point sources panned in 3D space
###[DirectSpeakers](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/plugins/direct_speakers)
For authoring metadata that applies to multichannel speaker beds

A third plugin to author metadata relating to ambisonic sources was considered but has not yet been implemented

##[Scene Master](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/plugins/scene)
For authoring high level metadata that can be applied to multiple sources, or the same source in multiple contexts. e.g. AudioProgramme or interactivity settings. Also handles communication with the reaper extension during import and export and muting unused inputs when monitoring multiple programmes.

##[Monitoring plugins](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/plugins/monitoring)
These render the audio and metadata to one of several fixed speaker layouts. One layout per plugin.

All the monitoring plugins share the same code, with the layout defined via compile time definitions specified [here](https://github.com/ebu/ear-production-suite/blob/main/ear-production-suite/plugins/monitoring/CMakeLists.txt)

A binaural rendering plugin is planned but not yet implemented.

#Routing
##Audio
Audio routing must be performed by REAPER. When importing, the routing is automatically set up but when adding new sources / plugins the routing must be performed manually.
Source tracks are routed to unique channels on the Scene master bus. This whole bus is routed to every monitoring plugin
##Metadata
Metadata specified within the plugins is represented by classes generated by protobuf. [The `.protobuf` source files](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/lib/messages) are used to generate c++ classes during [configure time](https://github.com/ebu/ear-production-suite/blob/081fc5c63295962003839bd5f799e5eadcecd09b/ear-production-suite/lib/CMakeLists.txt#L11)

The resulting c++ source and header files are located in the *build* directory under

    ear-production-suite/lib

This directory is added as an include path to the targets that make use of these classes

The protobuf classes are intended as a direct representation of the state of the plugins rather than the ADM they map to. For scene metadata, translation to and from ADM is performed on [import](https://github.com/ebu/ear-production-suite/blob/main/ear-production-suite/lib/include/programme_store_adm_populator.hpp) and [export](https://github.com/ebu/ear-production-suite/blob/main/ear-production-suite/lib/include/programme_store_adm_serializer.hpp). For input metadata, the extension performs the translation and reads/writes plugin automation/parameters via the REAPER API.

[NanoMessage Next Generation (nng)](https://nng.nanomsg.org/) is used to enable communication of metadata between the plugins as REAPER has no mechanism for routing complex metadata.
The nng C API is wrapped in C++ utility classes defined in the [nng-cpp](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/lib/include/nng-cpp) subfolder.


The inter-process communication methods are used (rather than intra) as we found this works more reliably cross platform and should also work in instances where a 32 bit host is being used with a plugin bridge. Communication endpoints are specified [here](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/lib/include/detail/constants.hpp)

Setting up the nng endpoint connections, sending/receiving messages and serializing/deserialization of sent/received protobuf buffers is handled by the [communication](https://github.com/ebu/ear-production-suite/tree/main/ear-production-suite/lib/include/communication) classes.

Additionally the SceneMaster plugin uses protobuf to serialise its state on project load/save - the other plugins do this manually via xml as when they were written there was an additional layer between protobuf and the plugins (rather than a conscious design choice)

